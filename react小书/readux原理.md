# redux 原理

## 为什么会出现 redux

1.  组件间需要共享数据
2.  使用状态提升，如果父组件的节点高度很高，就需要一级级传播 props 很麻烦
3.  使用 context，context 共享属性的话，太危险了，debug 非常麻烦

这就导致了一个问题

**组件需要共享数据**和**数据可能被任意修改导致不可预料的后果**

## 使用 reactjs 团队的方法

1.  所有对数据的操作必须通过 `dispath` 函数
2.  抽离出一个 store，`appstate`和`dispatch`通过函数调用返回
3.  使用订阅模式，将 render 函数加入到监听者列表，通过 dispatch 循环调用列表中的回调。这样我们只要通过 store 添加 render 函数，它自然回调用渲染
4.  优化性能--共享结构的对象，在 dispatch 的时候返回一个新对象，通过对比新旧对象，只渲染改变的
5.  优化代码将`state`和`action`结合

## 深入理解

1.  为什么要抽离出一个 store

因为渲染是要通过`render`函数去调用渲染函数的，需要传入`appstate`，而修改是通过 dispatch。为了方便就可以抽离 appstate 和 dispatch 组成一个函数。那么 state 就很干净，操作上都不会直接对 state 的产生影响，统一通过 store 嗲用

2.  监听数据变化

dispatch 后，每次需要手动调用 render 是很麻烦的，能否通过监听数据变化来自动改变。这里用到了，观察者模式(订阅模式)。只要把 render 函数加入到订阅者列表，disptach 的时候循环调用这个列表就可以了

3.  共享结构的对象

es6 中对象的解构其实是一种浅复制，那么利用这种利用解构，起始可以让新对象复制老对象的属性，但是覆盖重新复制的属性。就会达到一种共享未变的对象，保证改变的对象不相等

```
let a = {a:1, b:2}
let b = {...a, b:3}
a===b // false
a.a === b.a // true
a.b === b.b //false
```
