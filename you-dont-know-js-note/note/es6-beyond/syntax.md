# 语法

## 块级作用域
- 为了避免坑，let申明必须防灾块级作用域的最前面，并且最好let只用一次。
- let在for循环中当有函数使用回调，并且是一个闭包的时候，他会在for循环中每次重新申明一个变量，那么每次使用的这个变量就是正确的，不需要我们再去用闭包保存这个变量。
- 发生在块级作用域内部的函数声明现在被明确规定属于那个块儿的作用域

## const声明
- 创建的是常量，如其他语言，常量是不可被修改的，是只读属性
- 注意，不是值被冻结了，而是赋值这个行为只能进行一次
- 注意当一个数组或者对象作为常量赋值，那么如果常量的词法作用域不消失，这个变量是不会被垃圾回收的

## 扩展运算操作符和rest参数
- ...将一个可迭代对象扩展为参数形式／或者收集为数组

```
// 使用新的ES6方式
function foo(...args) {
	// `args`已经是一个真正的数组了

	// 丢弃`args`中的第一个元素
	args.shift();

	// 将`args`的所有内容作为参数值传给`console.log(..)`
	console.log( ...args );
}
bar( 0, 1, 2, 3 );
```
其中第一个...args是展开，第二个确实收集，用同一种方式表明了两种行为，很优雅。

## 解构赋值
```
var [a, b, c] = [1, 2, 3];
console.log(a, b, c);
```
注意在对象中，结构赋值是源-->target这种模式

## 插值字符串
插值字符串寻找的词法作用域

## 箭头函数
总是匿名函数表达式：在你需要短的内联函数表达式的地方采用=>，但保持你的一般长度的主函数原封不动  
箭头函数绑定的this是词法作用域
- 如果你有一个简短的，单语句内联函数表达式，它唯一的语句是某个计算后的值的return语句，并且 这个函数没有在它内部制造一个this引用，并且 没有自引用（递归，事件绑定/解除），并且 你合理地预期这个函数绝不会变得需要this引用或自引用，那么你就可能安全地将它重构为一个=>箭头函数。
- 如果你有一个内部函数表达式，它依赖于外围函数的var self = this黑科技或者.bind(this)调用来确保正确的this绑定，那么这个内部函数表达式就可能安全地变为一个=>箭头函数。
- 如果你有一个内部函数表达式，它依赖于外围函数的类似于var args = Array.prototype.slice.call(arguments)这样的东西来制造一个arguments的词法拷贝，那么这个内部函数就可能安全地变为一个=>箭头函数。

## for...of循环
for...of循环必须是一个可迭代对象，可迭代对象有：
- 数组
- 字符串
- generator
- 集合/类型化数组

