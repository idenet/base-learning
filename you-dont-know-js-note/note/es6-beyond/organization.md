# 组织
## 迭代器控制
在调用函数初始化一个迭代器后，第一个next运行至第一个yield，并接收yield后面的值，这时候函数会问迭代器，x应该接收什么值。那么第二个next中就传入需要的值。

## 模块
异步模块定义：AMD（requirejs，2.0开始可以延迟执行） 统一模块定义: CMD（sea.js）  
AMD是提前执行，CMD是延迟执行  
AMD依赖前置， CMD依赖就近  
ES6模块  
- ES6使用基于文件的模块，这意味着一个模块一个文件
- ES6模块的api是静态的
- ES6模块都是单例
- 你在模块的公有API上暴露的属性和方法不是值和引用的普通赋值。它们是在你内部模块定义中的标识符的实际绑定
- 导入一个模块和静态地请求它被加载是同一件事情

## 类
- class Foo 暗示着创建一个（特殊的）名为Foo的函数，与你在前ES6中所做的非常相似
- constructor(..)表示了这个Foo(..)函数的签名，和它的函数体内容
- 类方法不可枚举，对象方法默认是可枚举的
- 与对象字面量不同的是，在一个class内容的部分没有逗号分隔各个成员  
注意class与原来原型链继承的区别。
- class Foo的一个Foo(..)调用 必须 与new一起使用
- class foo不会被提升
- 在顶层全局作用域中的class Foo在这个作用域中创建了一个词法标识符Foo  
- 可以扩展原生类型
- 静态方法 static

