# 关于this
新手经常会犯的两个this认知错误
1. 将this理解成指向函数自身
2. this指向函数的作用域  
需要明确的是：this在任何情况下都不指向函数的词法作用域。并且this是在运行时进行绑定的。

# this全面解析
每个函数的this是在被调用时绑定的，完全取决于函数的调用位置（也就是函数的调用方法）

## 调用位置
函数在代码中被调用的位置。通过调用栈来确定函数被调用的位置

## 绑定规则
**严格模式下与绑定位置无关**

### 默认绑定
这是最常用的函数调用类型：独立调用，可以看作是无法应用其他规则时的默认规则。
1. 直接实用不带任何修饰的函数引用进行调用

## 隐式绑定
调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。即必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this隐式绑定到这个对象上
1. 对象调用链中只有离函数最近的调用才有作用。
2. 隐式丢失
```
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

var bar = obj.foo; // 函数别名
var a = "oops, global"; // a是全局对象属性

bar(); // "oops, global"
```
3. 参数传递，隐式赋值和隐式丢失一样，使用内置函数也是同样的效果
```
function foo() {
	console.log( this.a );
}

function doFoo(fn) {
	// fn仅仅作为foo的引用

	fn(); // 调用位置
}

var obj = {
	a: 2,
	foo: foo
};

var a = "oops, global"; // `a` also property on global object

doFoo( obj.foo ); // "oops, global"
```

## 显式绑定
通过call和apply方法显式绑定this，它们的第一个参数是一个对象，它们会吧这个对象绑定到this，接着在调用函数时指定这个this，通过
```foo.call(obj)```，我们可以在调用foo时强制把它的this绑定到obj上，如果传入一个原始值，那么就会使用它的包装对象  
问题是显式绑定无法解决丢失绑定的问题

### 硬绑定
将绑定方法写到一个函数里，那么无论如何调用函数，必然会调用绑定方法，这种形式称为硬绑定;硬绑定又两种使用场景：
1. 创建一个包裹函数，传入所有参数并返回接收到的所有值
2. 创建一个i可以重复使用的辅助函数

### API调用的上下文
许多库和js内置函数都提供了一个可选参数和bind一样，确保你的函数使用指定的this

### new绑定
js中的new的机制和面向对象语言完全不同。js，构造函数只是一些使用new操作符时被调用的函数。实际上不存在所谓的“构造函数”，只有对于函数的“构造调用”，发生构造函数调用时，会自动执行下面的操作：
1. 创建或者说构造一个全新的对象。
2. 这个新对象会被执行原型链接
3. 这个新对象会被绑定到函数调用的this上
4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象

## 判断this
1. 函数是否在new中调用（new绑定）？是的话，this绑定新创建的对象
2. 函数是否通过call，apply（显式绑定）或者硬绑定调用？是，this绑定的是指定对象
3. 函数是否在某个上下文中调用（隐式绑定）？是，this绑定的是那个上下文对象
4. 什么都不是的话，使用的是默认绑定，在严格模式下是undefined，非严格模式下是全局对象

## 绑定例外
在某些场景下this的绑定会出乎意料
1. 将null或者undefined作为this的绑定对象传入call、apply或者bind，并且bind可以实现函数柯里化
```
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}

// spreading out array as parameters
foo.apply( null, [2, 3] ); // a:2, b:3

// currying with `bind(..)`
var bar = foo.bind( null, 2 );
bar( 3 ); // a:2, b:3
```
⚠️这种方式并不安全，有可能导致全局对象的修改（在使用第三方库的时候）  
更安全的做法是传入一个特殊的对象，把this绑定到这个对象不会产生任何副作用ø(option+o)

## this词法
ES6中的箭头函数根据外层函数或者全局作用域来决定this，箭头函数绑定的this无法被修改

